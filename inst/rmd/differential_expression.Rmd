---
title: "Differential Gene Expression Analysis based on Salmon output of nf-core RNASeq pipeline."
output:
  html_notebook:
    code_folding: hide
    fig_height: 8
    fig_width: 10
params:
  path_config_json: ""
  path_salmon_counts: ""
  count_data: NULL
  out_path: ""
  save_csv: TRUE
  save_excel: TRUE
  save_deseq_rds: TRUE
  biomart_version: 97
  biomart_attributes: "none"
---

```{r setup, results = "hide"}

library(magrittr)
suppressWarnings(library(rmyknife))

# https://stackoverflow.com/questions/27992239/knitr-include-figures-in-report-and-output-figures-to-separate-files#comment71370705_27996644
knitr::opts_chunk$set(
  dev = c("png", "pdf"),
  fig.path = file.path(
    params$out_path,
    # Attach trailing '/'
    paste0("deseq_figures", .Platform$file.sep)
  )
)

```

## {.tabset}

### Overview & DESeq2 Run

This analysis largely follows the [DESeq2 vigniette](https://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html).

The basis for the analysis is the [salmon](https://combine-lab.github.io/salmon/) output of the [NFCore](https://nf-co.re/) [RNAseq](https://github.com/nf-core/RNAseq) pipeline.
Since the pipeline is lacking support for differential gene expression, this RMarkdown document intents to fix this.

Alternatively we can input a `count_data` data frame directly, containing a `gene_id` column and additional columns containing counts for each sample.

```{r print_parameters}

# Print settings as table
tibble::tibble(
  name = c("path_config_json", "path_salmon_counts", "out_path", "save_csv", "save_excel", "save_deseq_rds", "biomart_version", "biomart_attributes"),
  setting = c(params$path_config_json, params$path_salmon_counts, params$out_path, params$save_csv, params$save_excel, params$save_deseq_rds, params$biomart_version, params$biomart_attributes %>% paste(collapse = ", "))
) %>%
  knitr::kable()

```

#### Prepare DESeq2 Data Import

In this section we read in the Salmon counts for each gene.
Additionally, we load the json file containing group assignments for each sample.

```{r load_data, message = FALSE}

settings <- jsonlite::read_json(params$path_config_json)

if (!is.null(params$count_data)) {
  message("Using count_data dataframe provided as paramter")
  count_data <- params$count_data
} else {
  message("Loading counts from Salmon count CSV file")
  count_data <- readr::read_csv(
    params$path_salmon_counts,
    progress = FALSE
  )
}

```

We need to prepare the `colData` table required by DESeq2 to determine the experiment design.

```{r prepare_data}

# Make empty tibble
col_data <- tibble::tibble()

# Iterate over group names and create treatment column
settings$groups %>%
  names() %>%
  purrr::walk(function(group_name) {
    coldata_group <- tibble::tibble(
      sample_name = settings$groups[group_name] %>% unlist(),
      treatment = group_name
    )
    # Attach rows to col_data tibble
    col_data <<- col_data %>%
      dplyr::bind_rows(coldata_group)
  })

# Next we get the required comparisons. Either they are specified with the JSON
# file or we automatically create them based on the treatment column
# Iterate over comparisons to create comparison list
comparisons <- list()
if (!is.null(settings$comparisons)) {
  comparisons <- settings$comparisons
} else {
  treatments <- col_data %>%
    dplyr::select("treatment") %>%
    dplyr::distinct() %>%
    dplyr::pull()
  for (i in 1:length(treatments)) {
    for (j in 1:length(treatments)) {
      if (i > j) {
        treatment_a <- treatments[i][[1]]
        treatment_b <- treatments[j][[1]]
        comparison_name <- paste0(
          treatment_a,
          "_vs_",
          treatment_b
        )
        comparisons[comparison_name][[1]] <- list(
          "group_a" = treatment_a,
          "group_b" = treatment_b
        )
      }
    }
  }
}

# The order in coldata must be the same as in count_data
# We achieve this by joining based on the id in count_data
col_data <- tibble::tibble(
  id = count_data %>%
    # Get column names
    colnames() %>%
    # Remove "gene_id" column which is the first one
    .[2:length(.)]
) %>%
  dplyr::left_join(
    col_data,
    by = c("id" = "sample_name")
  )

```

Now we conduct some checks on the input tables to see if everything is fine.

```{r check_tables}
# Check if we have samples in count table that we do not have a treatment for
undefined_samples <- col_data %>%
  dplyr::filter(
    is.na(treatment)
  )

undefined_samples$id %>%
  purrr::walk(function(na_sample) {
    paste0("Removed sample ", na_sample, " because it was assigned to no treatment group in the JSON file") %>%
      warning()
    count_data <<- count_data %>%
      dplyr::select(-dplyr::contains(na_sample))
  })

col_data %<>%
  dplyr::filter(!is.na(treatment)) %>%
  # Convert treatment variable to factor as required by DESeq2
  dplyr::mutate(treatment = as.factor(treatment))

# Convert counts to integer to comply with DEseq2 standards
count_data %<>%
  dplyr::mutate_if(is.double, round) %>%
  dplyr::mutate_if(is.double, as.integer)
```

Here are the top entries of the raw count table:

```{r print_top_entries}

count_data %>%
  head() %>%
  knitr::kable()

```

The sample group assignment table is defined as follows:

```{r print_design_table}

col_data %>%
  knitr::kable()

```

Here are the comparisons we are running:

```{r print_comparisons}

comparisons %>% print()

```

#### Create DESeq2 data and run differential expression analysis

```{r create_deseq2_data}

deseq_data <- DESeq2::DESeqDataSetFromMatrix(
  countData = count_data %>% as.data.frame(),
  colData = col_data,
  design = ~treatment,
  tidy = TRUE
)

```

We can now run the differential expression analysis.

```{r run_differential_expression_analysis, cache = FALSE}

deseq_result <- DESeq2::DESeq(deseq_data)

# deseq_result_frame <- DESeq2::results(
#     deseq_result,
#     tidy = TRUE
#   ) %>%
#   tibble::as_tibble() %>%
#   # Arrange by adjusted p-value
#   dplyr::arrange(padj)

deseq_result_frame <- comparisons %>%
  purrr::imap(function(comparison, comparison_name) {
    paste0(
      "Get differential expression for comparison ",
      comparison_name,
      ", group a: ",
      comparison$group_a,
      ", group_b: ",
      comparison$group_b
    ) %>%
      message()

    DESeq2::results(
      deseq_result,
      tidy = TRUE,
      # Define which group we want to extract
      contrast = c("treatment", comparison$group_a, comparison$group_b)
    ) %>%
      tibble::as_tibble() %>%
      # Keep the comparison as one variable in the data frame
      dplyr::mutate(comparison = comparison_name) %>%
      # Arrange by adjusted p-value
      dplyr::arrange(padj)
  }) %>%
  # Bind all data frames into one big frame
  dplyr::bind_rows()
```

Now we are attaching the Biomart parameters if we have specified them.
This will be done using the [rmyknife package](https://github.com/paulklemm/rmyknife), which at the moment only has support for Mus Musculus.

```{r attach_biomart}
# For some reason caching this creates problems with the attached deseq_result frame
# To avoid this, we created a memoized version of the attach_biomart function

if (params$biomart_attributes != "none") {
  paste0(
    "Attaching biomart variables ",
    params$biomart_attributes
  ) %>%
    message()

  deseq_result_frame %<>%
    rmyknife::attach_biomart(
      ensembl_version = params$biomart_version,
      ensembl_id_var = "row",
      attributes = params$biomart_attributes,
    )
}
```

#### Save results

With the differential expression analysis complete we can now store away the resulting files based on the input parameters.

```{r output_deseq_results, cache = FALSE}

out_path_de_files <- file.path(params$out_path, "deseq_diff")

if (params$out_path != "") {
  paste0(
    "You set the output file path to ",
    out_path_de_files
  ) %>%
    message()
  # Create the folder
  dir.create(out_path_de_files)
  # Save csv
  if (params$save_csv) {
    # Get proper path
    csv_path <- file.path(
      out_path_de_files,
      "deseq2_diff.csv"
    )
    # Print status message
    paste0(
      "Save CSV file to ",
      csv_path
    ) %>%
      message()
    # Save CSV
    readr::write_csv(
      x = deseq_result_frame,
      path = csv_path
    )
  }
  # Save Excel
  if (params$save_excel) {
    # Get proper path
    excel_path <- file.path(
      out_path_de_files,
      "deseq2_diff.xlsx"
    )
    # Print status message
    paste0(
      "Save Excel file to ",
      excel_path
    ) %>%
      message()
    # Save Excel
    WriteXLS::WriteXLS(
      x = deseq_result_frame,
      ExcelFileName = excel_path,
      AdjWidth = TRUE,
      AutoFilter = TRUE,
      BoldHeaderRow = TRUE,
      FreezeRow = 1,
      SheetNames = c("deseq2_diff")
    )
  }
  # Save RDS
  if (params$save_deseq_rds) {
    # Get proper path
    rds_path <- file.path(
      out_path_de_files,
      "deseq2_diff.rds"
    )
    # Print status message
    paste0(
      "Save Rds file to ",
      rds_path
    ) %>%
      message()
    # Save RDS
    saveRDS(
      object = deseq_result,
      file = rds_path
    )
  }
}
```

### Differentially Expressed Genes

There are `r deseq_result_frame %>% tibble::as_tibble() %>% dplyr::filter(padj <= 0.05) %>% nrow()` entries differentially expressed.

*If you click on one of the download buttons above the table, give your browser a minute to process the request.*

```{r print_de_entries}

deseq_result_frame %>%
  dplyr::filter(padj <= 0.05) %>%
  dplyr::mutate_if(is.double, function(x) {
    return(round(x, 4))
  }) %>%
  DT::datatable(
    extensions = "Buttons",
    options = list(
      dom = "Bfrtip",
      buttons = c("copy", "csv", "excel", "pdf", "print")
    ),
    filter = "top"
  )
```

### PCA

The PCA shows which samples are similar on a genomic level.

```{r pca}

pca_data <- DESeq2::plotPCA(
  DESeq2::vst(deseq_result, blind = FALSE),
  intgroup = "treatment",
  returnData = TRUE
)

pca_plot <- pca_data %>%
  ggplot2::ggplot(ggplot2::aes(x = PC1, y = PC2, label = name, colour = group)) +
  ggplot2::geom_point() +
  ggplot2::ggtitle("Principal Component Analysis") +
  ggplot2::xlab(paste0("Principal Component 1 (", round(attr(pca_data, "percentVar")[1] * 100), "% variance explained)")) +
  ggplot2::ylab(paste0("Principal Component 2 (", round(attr(pca_data, "percentVar")[2] * 100), "% variance explained)")) +
  ggthemes::theme_tufte(base_family = "sans")

pca_plot
pca_plot + ggrepel::geom_text_repel()
```

### Distance Matrix

Heatmap of the sample-to-sample distances - https://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#differential-expression-analysis

```{r distance_matrix}

distance_matrix <- function(deseq_result) {
  vsdata <- DESeq2::vst(deseq_result, blind = FALSE)
  sampleDists <- dist(t(SummarizedExperiment::assay(vsdata)))
  sampleDistMatrix <- as.matrix(sampleDists)

  # rownames(sampleDistMatrix) <- paste(vsdata$condition, vsdata$type, sep="-")
  rownames(sampleDistMatrix) <- colnames(sampleDistMatrix)
  # colnames(sampleDistMatrix) <- NULL

  # colors <- colorRampPalette( rev(RColorBrewer::brewer.pal(9, "Blues")) )(255)
  pheatmap::pheatmap(sampleDistMatrix,
    clustering_distance_rows = sampleDists,
    clustering_distance_cols = sampleDists,
    col = colorRampPalette(RColorBrewer::brewer.pal(9, "Blues"))(255)
  )
}

distance_matrix(deseq_result)
```

Heat map of top-regulated genes accross all samples. This outlines the sample similarity.

```{r heat_map_top_n_counts, warning = FALSE}

deseq_counts <- deseq_result %>%
  DESeq2::counts(
    normalized = TRUE,
    replaced = FALSE
  ) %>%
  as.data.frame() %>%
  tibble::rownames_to_column("ensembl_id") %>%
  tidyr::pivot_longer(-ensembl_id, "sample_name") %>%
  dplyr::rename(count = value) %>%
  # Attach adjusted p-value
  dplyr::left_join(
    .,
    deseq_result_frame %>%
      dplyr::select(row, padj, comparison),
    by = c("ensembl_id" = "row")
  ) %>%
  # Order by adjusted p-value
  dplyr::arrange(padj) %>%
  tibble::as_tibble()

# Iterate over all comparison names
deseq_counts %>%
  dplyr::select(comparison) %>%
  dplyr::distinct() %>%
  dplyr::pull() %>%
  purrr::walk(
    function(comparison_name) {
      # Draw the heat map based on the current comparison
      deseq_counts_tmp <- deseq_counts %>%
        dplyr::filter(comparison == comparison_name) %>%
        dplyr::filter(padj <= 0.05)
      if (deseq_counts_tmp %>% nrow() == 0) {
        return()
      }

      deseq_counts_tmp %>%
        # Create adjusted count column suitable for plotting
        dplyr::mutate(adj_count = log10(count + 1)) %>%
        # Heatmap.2
        dplyr::select(ensembl_id, sample_name, adj_count) %>%
        tidyr::pivot_wider(names_from = sample_name, values_from = adj_count) %>%
        tibble::column_to_rownames("ensembl_id") %>%
        as.matrix() %>%
        t() %>%
        (function(dat_heatmap) {
          # Check if data frame meets minimum requirement
          if (nrow(dat_heatmap) < 2 | ncol(dat_heatmap) < 2) {
            paste0(
              "Cannot print heat map for comparison ",
              comparison_name,
              ". It contains ",
              nrow(deseq_counts_tmp),
              " significant genes."
            ) %>%
              warning()
            return()
          }
          # Print heat map
          dat_heatmap %>% gplots::heatmap.2(
            dendrogram = "row",
            scale = "none",
            trace = "none",
            main = paste0(
              comparison_name,
              ". Top ",
              ncol(.),
              " genes"
            ),
            labCol = NA,
            # Set labels
            xlab = "Genes",
            col = colorRampPalette(RColorBrewer::brewer.pal(9, "Blues"))(200),
            key.title = expression(-log[10](count + 1)),
            margins = c(4, 15)
          )
        })
    }
  )

# deseq_counts %>%
#   dplyr::filter(padj <= 0.05) %>%
#   # Create adjusted count column suitable for plotting
#   dplyr::mutate(adj_count = log10(count + 1)) %>%
#   # Heatmap.2
#   dplyr::select(-count, -padj) %>%
#   tidyr::pivot_wider(names_from = sample_name, values_from = adj_count) %>%
#   tibble::column_to_rownames("ensembl_id") %>%
#   as.matrix() %>%
#   t() %>%
#   gplots::heatmap.2(
#     dendrogram = "row",
#     scale = "none",
#     trace="none",
#     main = paste0(
#       "Counts for top ",
#       ncol(.),
#       " genes"
#     ),
#     labCol = NA,
#     # Set labels
#     xlab = "Genes",
#     col = colorRampPalette(RColorBrewer::brewer.pal(9, "Blues"))(200),
#     key.title = expression(-log[10](count+1))
#   )
# ggplot2::ggplot(
#   ggplot2::aes(
#     x = sample_name,
#     y = ensembl_id
#   )
# ) +
#   ggplot2::geom_tile(
#     ggplot2::aes(fill = adj_count)
#   ) +
#   ggplot2::scale_fill_distiller(
#     direction = 1,
#     name = "log(10) count + 1"
#   ) +
#   ggplot2::ggtitle("Heat map of top regulated genes") +
#   ggplot2::xlab("Sample Label") +
#   ggplot2::ylab("Genes") +
#   ggplot2::theme(
#     axis.text.x = ggplot2::element_text(
#       angle = 45,
#       vjust = 1,
#       hjust=1
#     ),
#     axis.text.y = ggplot2::element_blank(),
#     axis.ticks.y = ggplot2::element_blank()
#   )
```

```{r ma_plot, cache = FALSE}
# Skipping MA plot because we don't use it.
# DESeq2::plotMA(
#   DESeq2::lfcShrink(
#     deseq_result,
#     coef = 2,
#     type = "ashr"
#   ),
#   ylim = c(-4, 4)
# )
```

### Volcano Plot

Volcano Plot with top 10 genes annotated.

```{r volcano_plot}

deseq_result_frame %>%
  dplyr::select(comparison) %>%
  dplyr::distinct() %>%
  dplyr::pull() %>%
  purrr::walk(function(comparison_name) {
    volcano_plot <- deseq_result_frame %>%
      dplyr::filter(comparison == comparison_name) %>%
      # Remove entries that cannot be drawn
      dplyr::filter(!is.na(padj) & !is.na(log2FoldChange)) %>%
      # Draw the plot
      ggplot2::ggplot(
        ggplot2::aes(
          x = log2FoldChange,
          y = -log10(padj),
          color = (padj <= 0.05) %>% ifelse(., "significant", "not significant")
        )
      ) +
      ggplot2::geom_point(
        alpha = 0.3,
        size = 0.5
      ) +
      ggplot2::scale_color_manual(values = c("grey", "blue")) +
      ggplot2::ggtitle(paste0("Comparison: ", comparison_name)) +
      ggplot2::xlab(expression(log[2](fc))) +
      ggplot2::ylab(expression(-log[10](adjusted ~ p ~ value))) +
      ggplot2::labs(colour = "Significance") +
      ggthemes::theme_tufte(base_family = "sans") +
      ggrepel::geom_text_repel(
        data = . %>%
          dplyr::arrange(padj) %>%
          head(10),
        mapping = ggplot2::aes(label = external_gene_name),
        size = 3
      ) +
      ggplot2::geom_hline(
        yintercept = -log10(0.05),
        linetype = "dotted"
      )
    # Print volcano plot
    volcano_plot %>%
      print()
  })
```
