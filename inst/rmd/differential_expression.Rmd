---
title: "Differential Gene Expression Analysis based on Salmon output of nf-core RNASeq pipeline."
output:
  html_notebook:
    toc: yes
    toc_float: yes
    code_folding: hide
params:
  path_config_json: ""
  path_salmon_counts: ""
  out_path: ""
  save_csv: TRUE
  save_excel: TRUE
  save_deseq_rds: TRUE
  biomart_version: 97
  biomart_attributes: "none"
  dev: FALSE
---

```{r helper}

rmarkdown_params <- list()
# Hack to be able to use infinite moon reader
if (params$dev == TRUE) {
  rmarkdown_params$path_config_json <- "/beegfs/scratch/bruening_scratch/pklemm/2019-09-alain-rnaseq/analysis/groups_bat.json"
  rmarkdown_params$path_salmon_counts <- "/beegfs/scratch/bruening_scratch/pklemm/2019-09-alain-rnaseq/analysis/bat/results/salmon/salmon_merged_gene_counts.csv"
  rmarkdown_params$out_path <- "/beegfs/scratch/bruening_scratch/pklemm/2019-09-alain-rnaseq/analysis/bat/results/DESeq2"
  rmarkdown_params$save_csv <- TRUE
  rmarkdown_params$save_excel <- TRUE
  rmarkdown_params$save_deseq_rds <- TRUE
  rmarkdown_params$biomart_attributes <- "external_gene_name"
  rmarkdown_params$biomart_version <- 97
} else {
  rmarkdown_params$path_config_json <- params$path_config_json
  rmarkdown_params$path_salmon_counts <- params$path_salmon_counts
  rmarkdown_params$out_path <- params$out_path
  rmarkdown_params$save_csv <- params$save_csv
  rmarkdown_params$save_excel <- params$save_excel
  rmarkdown_params$save_deseq_rds <- params$save_deseq_rds
  rmarkdown_params$biomart_attributes <- params$biomart_attributes
  rmarkdown_params$biomart_version <- params$biomart_version
}

```

```{r setup, results = "hide"}

library(magrittr)
# https://stackoverflow.com/questions/27992239/knitr-include-figures-in-report-and-output-figures-to-separate-files#comment71370705_27996644
knitr::opts_chunk$set(
  dev = c("png", "pdf"),
  fig.path = file.path(
    rmarkdown_params$out_path,
    # Attach trailing '/'
    paste0("deseq_figures", .Platform$file.sep)
  )
)

```

# DESeq2 Analysis

This analysis largely follows the [DESeq2 vigniette](https://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html).

The basis for the analysis is the [salmon](https://combine-lab.github.io/salmon/) output of the [NFCore](https://nf-co.re/) [RNAseq](https://github.com/nf-core/RNAseq) pipeline.
Since the pipeline is lacking support for differential gene expression, this RMarkdown document intents to midigate this problem.

## Prepare DESeq2 Data Import

In this section we read in the Salmon counts for each gene.
Additionally, we load the json file containing group assignments for each sample.

```{r load_data, message = FALSE}

settings <- jsonlite::read_json(rmarkdown_params$path_config_json)
count_data <- readr::read_csv(
  rmarkdown_params$path_salmon_counts,
  progress = FALSE
)

```

We need to prepare the `colData` table required by DESeq2 to determine the experiment design.

```{r prepare_data}

# Make empty tibble
col_data <- tibble::tibble()

# Iterate over group names and create treatment column
settings$groups %>%
  names() %>%
  purrr::walk(function(group_name) {
    coldata_group <- tibble::tibble(
      sample_name = settings$groups[group_name] %>% unlist(),
      treatment = group_name
    )
    # Attach rows to col_data tibble
    col_data <<- col_data %>%
      dplyr::bind_rows(coldata_group)
  })

# The order in coldata must be the same as in count_data
# We achieve this by joining based on the id in count_data
col_data <- tibble::tibble(
  id = count_data %>%
    # Get column names
    colnames() %>%
    # Remove "gene_id" column which is the first one
    .[2:length(.)]
) %>%
  dplyr::left_join(
    col_data,
    by = c("id" = "sample_name")
  )

```

Now we conduct some checks on the input tables to see if everything is fine.

```{r check_tables}
# Check if we have samples in count table that we do not have a treatment for
undefined_samples <- col_data %>%
  dplyr::filter(
    is.na(treatment)
  )

undefined_samples$id %>%
  purrr::walk(function(na_sample) {
    paste0("Removed sample ", na_sample, " because it was assigned to no treatment group in the JSON file") %>%
      warning()
    count_data <<- count_data %>%
      dplyr::select(-dplyr::contains(na_sample))
    }
  )

col_data %<>%
  dplyr::filter(!is.na(treatment))

# Convert counts to integer to comply with DEseq2 standards
count_data %<>%
  dplyr::mutate_if(is.double, round) %>%
  dplyr::mutate_if(is.double, as.integer)

```

Here are the top entries of the raw count table:

```{r print_top_entries}

count_data %>%
  head() %>%
  knitr::kable()

```

The sample group assignment table is defined as follows:

```{r print_design_table}

col_data %>%
  knitr::kable()

```

## Create DESeq2 data and run differential expression analsis

```{r create_deseq2_data}

deseq_data <- DESeq2::DESeqDataSetFromMatrix(
  countData = count_data %>% as.data.frame(),
  colData = col_data,
  design = ~treatment,
  tidy = TRUE
)

```

We can now run the differential expression analysis.

```{r run_differential_expression_analysis, cache = FALSE}

deseq_result <- DESeq2::DESeq(deseq_data)
deseq_result_frame <- DESeq2::results(
    deseq_result,
    tidy = TRUE
  ) %>%
  tibble::as_tibble() %>%
  # Arrange by adjusted p-value
  dplyr::arrange(padj)
```

Now we are attaching the Biomart parameters if we have specified them.
This will be done using the [rmyknife package](https://github.com/paulklemm/rmyknife), which at the moment only has support for Mus Musculus.

```{r attach_biomart, cache = FALSE}
# For some reason caching this creates problems with the attached deseq_result frame
# To avoid this, we created a memoized version of the attach_biomart function

if (rmarkdown_params$biomart_attributes != "none") {
  paste0(
    "Attaching biomart variables ",
    rmarkdown_params$biomart_attributes
    ) %>%
  message()

  deseq_result_frame %<>%
    rmyknife::attach_biomart(
      ensembl_version = rmarkdown_params$biomart_version,
      ensembl_id_var = "row",
      attributes = rmarkdown_params$biomart_attributes,
    )
}

```

### Save results

With the differential expression analysis complete we can now store away the resulting files based on the input parameters.

```{r output_deseq_results, cache = TRUE}
if (rmarkdown_params$out_path != "") {
  paste0(
    "You set the output file path to ",
    rmarkdown_params$out_path
  ) %>%
    message()
  # Save csv
  if (rmarkdown_params$save_csv) {
    # Get proper path
    csv_path <- file.path(
      rmarkdown_params$out_path,
      "deseq2_diff.csv"
    )
    # Print status message
    paste0(
      "Save CSV file to ",
      csv_path
    ) %>%
      message()
    # Save CSV
    readr::write_csv(
      x = deseq_result_frame,
      path = csv_path
    )
  }
  # Save Excel
  if (rmarkdown_params$save_excel) {
    # Get proper path
    excel_path <- file.path(
      rmarkdown_params$out_path,
      "deseq2_diff.xlsx"
    )
    # Print status message
    paste0(
      "Save Excel file to ",
      excel_path
    ) %>%
      message()
    # Save Excel
    WriteXLS::WriteXLS(
      x = deseq_result_frame,
      ExcelFileName = excel_path,
      AdjWidth = TRUE,
      AutoFilter = TRUE,
      BoldHeaderRow = TRUE,
      FreezeRow = 1,
      SheetNames = c("deseq2_diff")
    )
  }
  # Save RDS
  if (rmarkdown_params$save_deseq_rds) {
    # Get proper path
    rds_path <- file.path(
      rmarkdown_params$out_path,
      "deseq2_diff.rds"
    )
    # Print status message
    paste0(
      "Save Rds file to ",
      rds_path
    ) %>%
      message()
    # Save RDS
    saveRDS(
      object = deseq_result,
      file = rds_path
    )
  }
}
```

### Print significant results

There are `r deseq_result_frame %>% tibble::as_tibble() %>% dplyr::filter(padj <= 0.05) %>% nrow()` entries differentially expressed.

*If you click on one of the download buttons above the table, give your browser a minute to process the request.*

```{r print_de_entries}

deseq_result_frame %>%
  dplyr::filter(padj <= 0.05) %>%
  dplyr::mutate_if(is.double, function(x) { return(round(x, 4)) }) %>%
  DT::datatable(
    extensions = 'Buttons',
    options = list(
      dom = 'Bfrtip',
      buttons = c('copy', 'csv', 'excel', 'pdf', 'print')
    )
  )

```

### Draw quality control plots

The PCA shows which samples are similar on a genomic level.

```{r pca}

pca_data <- DESeq2::plotPCA(
  DESeq2::vst(deseq_result, blind = FALSE),
  intgroup = "treatment",
  returnData = TRUE
)
pca_data %>%
  ggplot(aes(x=PC1, y=PC2, label = name, colour = group)) +
    geom_point() +
    ggtitle("Principal Component Analysis") +
    ggrepel::geom_text_repel() +
    xlab(paste0("Principal Component 1 (", round(attr(pca_data, "percentVar")[1] * 100), "% variance explained)")) +
    ylab(paste0("Principal Component 2 (", round(attr(pca_data, "percentVar")[2] * 100), "% variance explained)")) +
    ggthemes::theme_tufte(base_family = "sans")

```

Heatmap of the sample-to-sample distances - https://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#differential-expression-analysis

```{r distance_matrix}

distance_matrix <- function(deseq_result) {
  vsdata <- DESeq2::vst(deseq_result, blind = FALSE)
  sampleDists <- dist(t(SummarizedExperiment::assay(vsdata)))
  sampleDistMatrix <- as.matrix(sampleDists)
  
  # rownames(sampleDistMatrix) <- paste(vsdata$condition, vsdata$type, sep="-")
  rownames(sampleDistMatrix) <- colnames(sampleDistMatrix)
  # colnames(sampleDistMatrix) <- NULL

  #colors <- colorRampPalette( rev(RColorBrewer::brewer.pal(9, "Blues")) )(255)
  pheatmap::pheatmap(sampleDistMatrix,
    clustering_distance_rows = sampleDists,
    clustering_distance_cols = sampleDists,
    col = colorRampPalette(RColorBrewer::brewer.pal(9, "Blues"))(255)
  )
}

distance_matrix(deseq_result)
```

Heat map of top-regulated genes accross all samples. This outlines the sample similarity.

```{r heat_map_top_n_counts}

deseq_counts <- deseq_result %>%
  DESeq2::counts(
    normalized = TRUE,
    replaced = FALSE
  ) %>%
  as.data.frame() %>%
  tibble::rownames_to_column("ensembl_id") %>%
  tidyr::pivot_longer(-ensembl_id, "sample_name") %>%
  dplyr::rename(count = value) %>%
  # Attach adjusted p-value
  dplyr::left_join(
    .,
    deseq_result_frame %>%
      dplyr::select(row, padj),
    by = c("ensembl_id" = "row")
  ) %>%
  # Order by adjusted p-value
  dplyr::arrange(padj) %>%
  tibble::as_tibble()

deseq_counts %>%
  dplyr::filter(padj <= 0.05) %>%
  # Create adjusted count column suitable for plotting
  dplyr::mutate(adj_count = log10(count + 1)) %>%
  (function(df) {
    paste0(
      "Drawing heat map for ",
      df %>%
        dplyr::select(ensembl_id) %>%
        dplyr::distinct() %>%
        nrow(),
      " genes."
    ) %>%
      message()
    return(df)
  }) %>%
  # Heatmap.2
  dplyr::select(-count, -padj) %>%
  tidyr::pivot_wider(names_from = sample_name, values_from = adj_count) %>%
  tibble::column_to_rownames("ensembl_id") %>%
  as.matrix() %>%
  t() %>%
  gplots::heatmap.2(
    dendrogram = "row",
    scale = "none",
    trace="none",
    main = paste0(
      "Counts for top ",
      ncol(.),
      " genes"
    ),
    labCol = NA,
    # Set labels
    xlab = "Genes",
    col = colorRampPalette(RColorBrewer::brewer.pal(9, "Blues"))(200),
    key.title = expression(-log[10](count+1))
  )
  # ggplot2::ggplot(
  #   ggplot2::aes(
  #     x = sample_name,
  #     y = ensembl_id
  #   )
  # ) +
  #   ggplot2::geom_tile(
  #     ggplot2::aes(fill = adj_count)
  #   ) +
  #   ggplot2::scale_fill_distiller(
  #     direction = 1,
  #     name = "log(10) count + 1"
  #   ) +
  #   ggplot2::ggtitle("Heat map of top regulated genes") +
  #   ggplot2::xlab("Sample Label") +
  #   ggplot2::ylab("Genes") +
  #   ggplot2::theme(
  #     axis.text.x = ggplot2::element_text(
  #       angle = 45,
  #       vjust = 1,
  #       hjust=1
  #     ),
  #     axis.text.y = ggplot2::element_blank(),
  #     axis.ticks.y = ggplot2::element_blank()
  #   )
```

```{r ma_plot, cache = FALSE}
DESeq2::plotMA(
  DESeq2::lfcShrink(
    deseq_result,
    coef = 2,
    type = "ashr"
  ),
  ylim = c(-4, 4)
)
```

Volcano Plot with top 10 genes annotated.

```{r volcano_plot}

deseq_result_frame %>%
  # Remove entries that cannot be drawn
  dplyr::filter(!is.na(padj) & !is.na(log2FoldChange)) %>%
  ggplot2::ggplot(
    ggplot2::aes(
      x = log2FoldChange,
      y = -log10(padj),
      color = (padj <= 0.05) %>% ifelse(., "significant", "not significant")
    )
  ) +
    ggplot2::geom_point(
      alpha = 0.3,
      size = 0.5
    ) +
    ggplot2::scale_color_manual(values = c("grey", "blue")) +
    ggplot2::xlab(expression(log[2](fc))) + 
    ggplot2::ylab(expression(-log[10](adjusted~p~value))) +
    ggplot2::labs(colour = "Significance") +
    ggthemes::theme_tufte(base_family = "sans") +
    ggrepel::geom_text_repel(
      data = . %>%
        dplyr::arrange(padj) %>%
        head(10),
      mapping = ggplot2::aes(label = external_gene_name),
      size = 3
    ) +
    ggplot2::geom_hline(
      yintercept = -log10(0.05),
      linetype = "dotted"
    )

```
